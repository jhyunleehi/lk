

#### source code

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
    FILE *fp = fopen("hello.txt", "w");

    if (fp) {
        fprintf(fp, "hello linux filesystem\n");
        fclose(fp);
        sync();
    }
}
```

#### debug

```sh
# gcc -g -pg wr write.c
# gdb ./wr
(gdb) b main
(gdb) run
(gdb) info proc
process 826968
cmdline = '/home/jhyunlee/code/linuxkernel/code_file/wr'
cwd = '/home/jhyunlee/code/linuxkernel/code_file'
exe = '/home/jhyunlee/code/linuxkernel/code_file/wr'
(gdb)
```



### ftrace

```sh
root@ubuntu20:/sys/kernel/debug/tracing# cat available_filter_functions  | grep ext4_file_open
ext4_file_open
```



####   ft.sh

```sh
echo 0 > tracing_on
echo 0 > events/enable
echo function > current_tracer
echo 1 > events/sched/sched_switch/enable
echo 1 > events/raw_syscalls/sys_enter/enable
echo 1 > events/raw_syscalls/sys_exit/enable
echo ext4_file_open ext4_file_write_iter > set_ftrace_filter
echo ext4_file_read_iter ext4_llseek >> set_ftrace_filter
echo ext4_sync_file __close_fd >> set_ftrace_filter
echo 1 > options/func_stack_trace
echo 1 > options/sym-offset
echo 1 > tracing_on
```

#### run app

```shell
./wr
```

#### log.sh

```shell
#!/bin/bash
#run as root
echo 0 > /sys/kernel/debug/tracing/tracing_on
echo 0 > /sys/kernel/debug/tracing/events/enable
echo 0 > /sys/kernel/debug/tracing/options/stacktrace
cp  /sys/kernel/debug/tracing/trace ftrace.log
```



```sh
           <...>-1054807 [001] .... 108655.957667: sys_enter: NR 59 (556bcfa11a98, 556bcedf2b90, 556bcedf2ba8, 7f3609024850, 556bcfa11a98, 7f3609024580)
           <...>-1054807 [001] .... 108655.957706: ext4_file_open+0x0/0x2e0 <-do_dentry_open+0x156/0x370
<...>-1054807 [001] .... 108655.957710: <stack trace>
 => ext4_file_open+0x5/0x2e0
 => do_dentry_open+0x156/0x370
 => vfs_open+0x2d/0x30
 => path_openat+0xb17/0x1120
 => do_filp_open+0x91/0x100
 => do_open_execat+0x71/0x1a0
 => bprm_execve+0x126/0x290
 => do_execveat_common.isra.0+0x189/0x1c0
 => __x64_sys_execve+0x37/0x50
 => do_syscall_64+0x38/0x90
 => entry_SYSCALL_64_after_hwframe+0x44/0xa9
```

* ftrace로 확인하는 event 중심으로 kernel 함수 호출 관계를 확인하는 것과 차이는 없지만, 확인하려고 하는 event가 많이 섞여져 있서 분리하기가 좀 힘드네..

![img](img/a0386257_5d7e1366d1c9e.png)





## uftrace

#### user level

```sh
root@ubuntu20:/home/jhyunlee/code/linuxkernel/code_file# uftrace ./wr
# DURATION     TID     FUNCTION
   0.240 us [844328] | __monstartup();
   0.090 us [844328] | __cxa_atexit();
            [844328] | main() {
  25.588 us [844328] |   fopen();
   2.464 us [844328] |   fwrite();
  50.826 us [844328] |   fclose();
            [844328] |   sync() {
 299.105 us [844328] |     /* linux:schedule */
   1.527 ms [844328] |     /* linux:schedule */
  26.841 us [844328] |     /* linux:schedule */
   2.202 ms [844328] |   } /* sync */
   2.283 ms [844328] | } /* main */
```



## uftrace kernel

```
# uftrace record -K 30  ./wr
# uftrace  tui -N smp_apic_timer_interrupt
# uftrace tui -F fopen  -N smp_apic_timer_interrupt -t 10us

  528.179 us : (1) wr                                                                                                                                                                      
  528.179 us : (1) fopen
   18.034 us :  ├─(1) handle_mm_fault
   16.481 us :  │ (1) __handle_mm_fault
   15.580 us :  │ (1) do_fault
   15.138 us :  │ (1) filemap_map_pages
   13.325 us :  │ (1) alloc_set_pte
   12.153 us :  │ (1) page_add_file_rmap
  502.301 us :  └─(1) __x64_sys_openat   <<====
  501.920 us :    (1) do_sys_open   <<===
  501.530 us :    (1) do_sys_openat2 
  493.394 us :    (1) do_filp_open  <=======
  492.593 us :    (1) path_openat         <=====
   20.469 us :     ├─(1) alloc_empty_file
   20.067 us :     │ (1) __alloc_file
   11.451 us :     │ (1) security_file_alloc
  402.494 us :     ├─(1) ext4_create              <=======
  217.086 us :     │  ├─(1) __ext4_new_inode
   36.609 us :     │  │  ├─(1) new_inode          
   35.156 us :     │  │  │ (1) new_inode_pseudo
   16.491 us :     │  │  │ (1) alloc_inode   <<=======
   12.693 us :     │  │  │ (1) ext4_alloc_inode   <<================
   12.974 us :     │  │  ├─(1) __ext4_journal_start_sb
   11.422 us :     │  │  │ (1) jbd2__journal_start
   13.225 us :     │  │  ├─(1) ext4_inode_bitmap_csum_set
   12.463 us :     │  │  │ (1) crypto_shash_update
   11.952 us :     │  │  │ (1) crc32c_pcl_intel_update
   10.329 us :     │  │  │ (1) kernel_fpu_begin_mask
   20.829 us :     │  │  ├─(1) insert_inode_locked
   10.871 us :     │  │  │ (1) __sysvec_irq_work
   29.976 us :     │  │  ├─(1) ext4_ext_tree_init
   29.585 us :     │  │  │ (1) __ext4_mark_inode_dirty
   21.711 us :     │  │  │ (1) ext4_mark_iloc_dirty
   19.967 us :     │  │  │ (1) ext4_do_update_inode
   49.322 us :     │  │  └─(1) __ext4_mark_inode_dirty
  180.168 us :     │  └─(1) ext4_add_nondir
  136.996 us :     │     ├─(1) ext4_add_entry
  134.942 us :     │     │ (1) ext4_dx_add_entry
   31.068 us :     │     │  ├─(1) dx_probe
   10.149 us :     │     │  │  ├─(1) __ext4_read_dirblock
   10.820 us :     │     │  │  └─(1) ext4fs_dirhash
   15.379 us :     │     │  ├─(1) __ext4_journal_get_write_access
   77.205 us :     │     │  └─(1) add_dirent_to_buf
   55.334 us :     │     │     ├─(1) __ext4_mark_inode_dirty
   16.281 us :     │     │     └─(1) ext4_handle_dirty_dirblock
   11.992 us :     │     │       (1) __ext4_handle_dirty_metadata
   39.263 us :     │     └─(1) __ext4_mark_inode_dirty
   31.469 us :     │       (1) ext4_mark_iloc_dirty
   11.211 us :     │        ├─(1) ext4_fc_track_inode
   10.399 us :     │        │ (1) ext4_inode_journal_mode
   19.646 us :     │        └─(1) ext4_do_update_inode
   13.274 us :     ├─(1) vfs_open
   12.884 us :     │ (1) do_dentry_open
   11.342 us :     └─(1) terminate_walk
```

#### 1. __x64_sys_openat()

```
jhyunlee@ubuntu20:~/code/linux/arch/x86/entry/syscalls$ grep  open syscall_64.tbl 
2       common  open                    __x64_sys_open
240     common  mq_open                 __x64_sys_mq_open
257     common  openat                  __x64_sys_openat <<=================
298     common  perf_event_open         __x64_sys_perf_event_open
304     common  open_by_handle_at       __x64_sys_open_by_handle_at
428     common  open_tree               __x64_sys_open_tree
430     common  fsopen                  __x64_sys_fsopen
434     common  pidfd_open              __x64_sys_pidfd_open
```



```c
</include/linux/syscalls.h>
extern long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode);                    
```

* 

#### 2. do_sys_open

```c
<fs/open.c>
SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
{
	if (force_o_largefile())
		flags |= O_LARGEFILE;

	return do_sys_open(AT_FDCWD, filename, flags, mode);
}

long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
	struct open_flags op;
	int fd = build_open_flags(flags, mode, &op);
	struct filename *tmp;

	if (fd)
		return fd;

	tmp = getname(filename);
	if (IS_ERR(tmp))
		return PTR_ERR(tmp);

	fd = get_unused_fd_flags(flags); <<=== 1단계
	if (fd >= 0) {
		struct file *f = do_filp_open(dfd, tmp, &op);  <<=== 2단계
		if (IS_ERR(f)) {
			put_unused_fd(fd);
			fd = PTR_ERR(f);
		} else {
			fsnotify_open(f);  <<=== 3단계
			fd_install(fd, f);
		}
	}
	putname(tmp);
	return fd;
}


```



```c
struct fdtable {
	unsigned int max_fds;
	struct file __rcu **fd;      /* current fd array */
	unsigned long *close_on_exec;
	unsigned long *open_fds;
	unsigned long *full_fds_bits;
	struct rcu_head rcu;
};


int get_unused_fd_flags(unsigned flags)
{
	return __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);
}

/*
 * allocate a file descriptor, mark it busy.
 */
int __alloc_fd(struct files_struct *files, unsigned start, unsigned end, unsigned flags)
{
	unsigned int fd;
	int error;
	struct fdtable *fdt;

	spin_lock(&files->file_lock);
repeat:
	fdt = files_fdtable(files);
	fd = start;
	if (fd < files->next_fd)
		fd = files->next_fd;

	if (fd < fdt->max_fds)
		fd = find_next_fd(fdt, fd);

	/*
	 * N.B. For clone tasks sharing a files structure, this test
	 * will limit the total number of files that can be opened.
	 */
	error = -EMFILE;
	if (fd >= end)
		goto out;

	error = expand_files(files, fd);
	if (error < 0)
		goto out;

	/*
	 * If we needed to expand the fs array we
	 * might have blocked - try again.
	 */
	if (error)
		goto repeat;

	if (start <= files->next_fd)
		files->next_fd = fd + 1;

	__set_open_fd(fd, fdt);
	if (flags & O_CLOEXEC)
		__set_close_on_exec(fd, fdt);
	else
		__clear_close_on_exec(fd, fdt);
	error = fd;
#if 1
	/* Sanity check */
	if (rcu_access_pointer(fdt->fd[fd]) != NULL) {
		printk(KERN_WARNING "alloc_fd: slot %d not NULL!\n", fd);
		rcu_assign_pointer(fdt->fd[fd], NULL);
	}
#endif

out:
	spin_unlock(&files->file_lock);
	return error;
}
```

