# ftrace

## ftrace

#### get ftrace.sh

```sh
#!/bin/bash
#run as root
cd /sys/kernel/debug/tracing
echo 0 > tracing_on
echo nop > current_tracer
echo 0 > events/enable
echo 0 > options/stacktrace
# echo 'p:enqueue_task_fair enqueue_task_fair' > kprobe_events  
# echo 1 > events/kprobes/enqueue_task_fair/enable
echo 1 > tracing_on 
echo 1 > events/irq/irq_handler_exit/enable
echo 1 > events/irq/irq_handler_entry/enable
echo 1 > options/stacktrace
cat trace_pipe
```

#### get.log

```sh
#!/bin/bash
#run as root
echo 0 > /sys/kernel/debug/tracing/tracing_on
echo 0 > /sys/kernel/debug/tracing/events/enable
echo 0 > /sys/kernel/debug/tracing/options/stacktrace
cp  /sys/kernel/debug/tracing/trace ftrace.log
```

#### writeback

```sh
$ sudo su
$ cd /sys/kernel/debug/tracing
$ echo 0 > events/enable
$ echo 0 > options/stacktrace
$ echo nop > current_tracer

$ echo smp_apic_timer_interrupt > set_graph_function
$ echo wb_workfn > set_graph_function
$ echo function_graph > current_tracer
$ cat trace
```

### interrupt

```sh
# 리눅스 커널 이벤트 추적준비 tracepoint
$ sudo su
$ cd /sys/kernel/debug/tracing
$ echo 0 > events/enable
$ echo 0 > options/stacktrace
$ echo nop > current_tracer

# 인터럽트 처리함수 smp_apic_timer_interrupt() 추적하기
$ echo 1 > events/irq_vectors/local_timer_entry/enable
$ echo smp_apic_timer_interrupt > set_graph_function
$ echo function_graph > current_tracer
$ cat trace
```



#### network

```sh
# 커널함수 추적 ftrace 초기화 
$ sudo su
$ cd /sys/kernel/debug/tracing
$ echo nop > current_tracer
$ echo 0 > events/enable
$ echo 0 > options/stacktrace
$ echo > trace

# 또다른 터미널로 ping 8.8.8.8 테스트
$ ping 8.8.8.8

# ping pid 알아내서 tracing 필터링
$ ps -ef | grep ping
$ echo "pid" > set_ftrace_pid
$ echo "pid" > set_event_pid

# 네트워크 패킷을 보내는 dev_hard_start_xmit 호출까지 흐름 추적한다.
$ echo 'p:dev_hard_start_xmit dev_hard_start_xmit' > kprobe_events
$ echo 1 > events/kprobes/dev_hard_start_xmit/enable

$ echo function_graph > current_tracer
$ echo dev_hard_start_xmit > set_graph_function
$ echo 1 > options/stacktrace
$ echo smp_apic_timer_interrupt > set_graph_notrace

# 패킷 보낼때 DMA 영역 복사후 인터럽트 irq 발생 되는것을 확인하고
# uftrace tui -d client.uftrace.data 의 call-graph 와 비교해본다.
$ cat trace_pipe
```





## uftrace

- `record` : runs a program and saves the trace data
- `replay` : shows program execution in the trace data
- `report` : shows performance statistics in the trace data
- `live` : does record and replay in a row (default)
- `info` : shows system and program info in the trace data
- `dump` : shows low-level trace data
- `recv` : saves the trace data from network
- `graph` : shows function call graph in the trace data
- `script` : runs a script for recorded trace data
- 
- `tui` : show text user interface for graph and report

#### uftrace

```sh
# uftrace record -d pid_maps.uftrace.data --force -K 30 /bin/cat /proc/self/
# uftrace record --force -K 30 /bin/cat /proc/self/maps
# uftrace tui -t 8us -N smp_apic_timer_interrupt@kernel
# uftrace replay -t 8us -N smp_apic_timer_interrupt@kernel
```