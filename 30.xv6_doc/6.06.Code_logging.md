### Code: logging

A typical use of the log in a system call looks like this:

```c
begin_op();
...
bp = bread(...);
bp->data[...] = ...;
log_write(bp);
...
end_op();
```

#### begin_op

begin_op(4628)은 로깅 시스템이 현재 커밋 중이 아닐 때까지, 그리고 이 호출과 현재 실행 중인 모든 시스템 호출의 쓰기를 보유하기에 충분한 여유 로그 공간이 있을 때까지 기다립니다. log.outstanding은 해당 호출 수를 계산합니다. 증분은 공간을 예약하고 이 시스템 호출 중에 커밋이 발생하는 것을 방지합니다. 코드는 각 시스템 호출이 최대 MAXOPBLOCKS개의 개별 블록을 쓸 수 있다고 보수적으로 가정합니다.
log_write(4722)는 bwrite의 프록시 역할을 합니다. 블록의 섹터 번호를 메모리에 기록하고 디스크의 로그에 슬롯을 예약하고 버퍼 B_DIRTY를 표시하여 블록 캐시가 해당 섹터를 축출하지 못하도록 합니다. 블록은 커밋될 때까지 캐시에 남아 있어야 합니다.
그때까지 캐시된 복사본은 수정 사항의 유일한 기록입니다. 커밋이 끝날 때까지 디스크의 해당 위치에 쓸 수 없습니다. 동일한 트랜잭션의 다른 읽기는 수정 사항을 확인해야 합니다. log_write는 단일 트랜잭션 동안 블록이 여러 번 작성될 때 이를 통지하고 해당 블록을 로그의 동일한 슬롯에 할당합니다. 이 최적화를 종종 흡수라고 합니다. 예를 들어, 여러 파일의 inode를 포함하는 디스크 블록은 트랜잭션 내에서 여러 번 작성되는 것이 일반적입니다. 여러 디스크 쓰기를 하나로 흡수함으로써 파일 시스템은 로그 공간을 절약할 수 있고 디스크 블록의 복사본 하나만 디스크에 기록해야 하기 때문에 더 나은 성능을 얻을 수 있습니다.

#### end_op

end_op(4653)은 먼저 미해결 시스템 호출 수를 줄입니다. 카운트가 이제 0이면 commit()을 호출하여 현재 트랜잭션을 커밋합니다. 이 과정에는 4단계가 있습니다. write_log()(4683)는 트랜잭션에서 수정된 각 블록을 버퍼 캐시에서 디스크의 로그 슬롯으로 복사합니다. write_head()(4604)는 헤더 블록을 디스크에 씁니다. 이것은 커밋 지점이고 쓰기 후 충돌은 로그에서 트랜잭션의 쓰기를 재생하는 복구로 이어집니다. 

install_trans() in-stall_trans(4572)는 로그에서 각 블록을 읽고 파일 시스템의 적절한 위치에 씁니다. 마지막으로 end_op는 카운트가 0인 로그 헤더를 작성합니다. 이것은 다음 트랜잭션이 기록된 블록을 쓰기 시작하기 전에 일어나야 하므로 충돌로 인해 후속 트랜잭션의 기록된 블록이 있는 한 트랜잭션의 헤더를 사용하여 복구가 발생하지 않습니다.
recover_from_log(4618)는 첫 번째 사용자 프로세스가 실행되기 전에 부팅하는 동안 호출되는 initlog(4556)에서 호출됩니다. (2794) 로그 헤더를 읽고 헤더에 커밋된 트랜잭션이 포함되어 있음을 나타내는 경우 end_op의 동작을 모방합니다.
로그의 사용 예는 filewrite(5752)에서 발생합니다. 트랜잭션은 다음과 같습니다.


이 코드는 로그 오버플로를 방지하기 위해 한 번에 몇 개 섹터의 개별 트랜잭션으로 대용량 쓰기를 나누는 루프로 래핑됩니다. writei에 대한 호출은 이 트랜잭션의 일부로 파일의 inode, 하나 이상의 비트맵 블록 및 일부 데이터 블록과 같은 많은 블록을 씁니다.





```c
begin_op();
ilock(f->ip);
r = writei(f->ip, ...);
iunlock(f->ip);
end_op();
```

