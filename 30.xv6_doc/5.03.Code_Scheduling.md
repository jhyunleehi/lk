## Code: Scheduling



마지막 섹션에서는 swtch의 하위 수준 세부 정보를 살펴보았습니다. 이제 swtch를 주어진 것으로 간주하고 프로세스에서 스케줄러로, 다시 프로세스로 전환하는 것과 관련된 규칙을 살펴보겠습니다. CPU를 포기하려는 프로세스는 프로세스 테이블 잠금 ptable.lock을 획득하고 보유하고 있는 다른 잠금을 해제하고 자체 상태(proc->state)를 업데이트한 다음 sched를 호출해야 합니다. Yield(2772)는 이 규칙을 따르고 나중에 살펴보겠습니다. Sched는 이러한 조건(2757-2762)을 다시 확인한 다음 해당 조건의 의미를 확인합니다. 잠금이 유지되기 때문에 CPU는 인터럽트가 비활성화된 상태에서 실행되어야 합니다. 마지막으로 sched는 swtch를 호출하여 현재를 저장합니다.
proc->context의 컨텍스트로 이동하고 cpu->scheduler의 스케줄러 컨텍스트로 전환합니다. Swtch는 스케줄러의 swtch가 반환된 것처럼 스케줄러의 스택에서 반환됩니다(2728). 스케줄러는 for 루프를 계속하고 실행할 프로세스를 찾아 해당 프로세스로 전환하고 주기를 반복합니다.



우리는 방금 xv6이 swtch에 대한 호출에서 ptable.lock을 보유하고 있음을 보았습니다. swtch의 호출자는 이미 잠금을 보유하고 있어야 하며 잠금 제어는 전환된 코드로 전달됩니다. 이 규칙은 잠금에서 일반적이지 않습니다. 일반적인 규칙은 잠금을 획득한 스레드가 잠금 해제도 담당하므로 추론하기가 더 쉽습니다.
정확성에 대해. 컨텍스트 전환의 경우 ptable.lock이 swtch에서 실행하는 동안 true가 아닌 프로세스의 상태 및 컨텍스트 필드에 대한 불변성을 보호하기 때문에 일반적인 규칙을 깨는 것이 필요합니다. swtch 중에 ptable.lock이 유지되지 않은 경우 발생할 수 있는 문제의 한 가지 예: yield가 상태를 RUNNABLE로 설정한 후 swtch가 자체 커널 스택 사용을 중지하기 전에 다른 CPU가 프로세스를 실행하기로 결정할 수 있습니다. 결과는 동일한 스택에서 실행되는 두 개의 CPU가 되며 이는 옳지 않습니다.



커널 스레드는 항상 sched의 프로세서를 포기하고 항상 스케줄러의 동일한 위치로 전환합니다. 이는 (거의) 항상 sched의 프로세스로 전환됩니다. 따라서 xv6이 스레드를 전환하는 행 번호를 인쇄하면 (2728), (2766), (2728), (2766) 등의 간단한 패턴을 관찰할 수 있습니다. 두 스레드 간에 이러한 양식화된 전환이 발생하는 절차를 코루틴이라고 하는 경우가 있습니다. 이 예에서 sched와 스케줄러는 서로의 공동 루틴입니다.
새 프로세스에 대한 스케줄러의 swtch가 sched에서 끝나지 않는 한 가지 경우가 있습니다. 우리는 2장에서 이 경우를 보았습니다. 새로운 프로세스가 처음 스케줄링되면 forkret(2783)에서 시작됩니다. Forkret은 ptable.lock을 해제하여 이 규칙을 준수하기 위해서만 존재합니다. 그렇지 않으면 새 프로세스가 trapret에서 시작될 수 있습니다.



스케줄러(2708)는 간단한 루프를 실행합니다. 실행할 프로세스를 찾고 멈출 때까지 실행하고 반복합니다. 스케줄러는 대부분의 작업에 대해 ptable.lock을 보유하지만 외부 루프가 반복될 때마다 잠금을 해제하고 명시적으로 인터럽트를 활성화합니다. 이것은 이 CPU가 유휴 상태인 특수한 경우에 중요합니다(RUNNABLE 프로세스를 찾을 수 없음).
잠금이 계속 유지된 상태에서 유휴 스케줄러가 반복되면 프로세스를 실행하는 다른 CPU는 컨텍스트 전환이나 프로세스 관련 시스템 호출을 수행할 수 없으며 특히 유휴 CPU를 중단하기 위해 프로세스를 RUNNABLE로 표시할 수 없습니다. 일정 루프에서 벗어납니다. 유휴 CPU에서 주기적으로 인터럽트를 활성화하는 이유는 프로세스(예: 셸)가 I/O를 기다리고 있기 때문에 RUNNABLE 프로세스가 없을 수 있기 때문입니다. 스케줄러가 인터럽트를 항상 비활성화 상태로 두면 I/O가 도착하지 않습니다.



스케줄러는 p->state == RUNNABLE인 실행 가능한 프로세스를 찾는 프로세스 테이블을 반복합니다. 프로세스를 찾으면 CPU당 현재 프로세스 변수 proc을 설정하고 switchuvm을 사용하여 프로세스의 페이지 테이블로 전환하고 프로세스를 RUNNING으로 표시한 다음 swtch를 호출하여 실행을 시작합니다(2722-2728).
스케쥴링 코드의 구조에 대해 생각하는 한 가지 방법은 각 프로세스에 대해 일련의 불변을 적용하도록 배열하고 이러한 불변이 참이 아닐 때마다 ptable.lock을 유지하는 것입니다. 하나의 불변성은 프로세스가 실행 중이면 타이머 인터럽트의 수율이 프로세스에서 올바르게 전환될 수 있도록 설정해야 한다는 것입니다. 이것은 CPU 레지스터가 프로세스의 레지스터 값을 보유해야 함을 의미합니다(즉, 실제로 컨텍스트에 있지 않음), %cr3은 프로세스의 페이지 테이블을 참조해야 하며, %esp는 swtch가 레지스터를 올바르게 푸시할 수 있도록 프로세스의 커널 스택을 참조해야 합니다. proc은 프로세스의 proc[] 슬롯을 참조해야 합니다. 또 다른 불변은 프로세스가 다음과 같다는 것입니다.
RUNNABLE, 유휴 CPU의 스케줄러가 실행할 수 있도록 설정해야 합니다. 이것은 p->context가 프로세스의 커널 스레드 변수를 보유해야 하고, 프로세스의 커널 스택에서 실행 중인 CPU가 없고, CPU의 %cr3이 프로세스의 페이지 테이블을 참조하지 않으며, CPU의 proc이 프로세스를 참조하지 않는다는 것을 의미합니다.



위의 불변성을 유지하는 것이 xv6이 한 스레드(종종 yield)에서 ptable.lock을 획득하고 다른 스레드(스케줄러 스레드 또는 다른 다음 커널 스레드)에서 잠금을 해제하는 이유입니다. 코드가 실행 중인 프로세스의 상태를 RUNNABLE로 수정하기 시작하면 복원이 완료될 때까지 잠금을 유지해야 합니다.
불변성: 가장 정확한 릴리스 포인트는 스케줄러가 프로세스의 페이지 테이블 사용을 중지하고 proc을 지운 후입니다. 마찬가지로 스케줄러가 실행 가능한 프로세스를 RUNNING으로 변환하기 시작하면 커널 스레드가 완전히 실행될 때까지 잠금을 해제할 수 없습니다(swtch 이후, 예를 들어 yield에서).
ptable.lock은 다른 것들도 보호합니다: 프로세스 ID와 여유 프로세스 테이블 슬롯의 할당, 종료와 대기 사이의 상호작용, 깨어나지 않는 것을 피하기 위한 기계(다음 섹션 참조), 그리고 아마도 다른 것들도 마찬가지입니다. 분명히 명확성과 아마도 성능을 위해 ptable.lock의 다른 기능을 분할할 수 있는지 여부에 대해 생각해 볼 가치가 있습니다.