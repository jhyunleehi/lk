## Code: Wait, exit, and kill

Sleep과 wakeup은 다양한 종류의 기다림에 사용될 수 있습니다. 0장에서 볼 수 있는 흥미로운 예는 부모 프로세스가 자식이 종료될 때까지 기다리는 데 사용하는 대기 시스템 호출입니다. xv6에서 자식이 종료되면 즉시 죽지 않습니다. 대신 부모 호출이 종료를 알기 위해 대기할 때까지 ZOMBIE 프로세스 상태로 전환합니다. 그러면 부모는 프로세스와 관련된 메모리를 해제하고 재사용을 위해 struct proc을 준비할 책임이 있습니다. 부모가 자식보다 먼저 종료하면 init 프로세스는 자식을 채택하고 기다립니다. 따라서 모든 자식은 자식 이후에 정리할 부모를 갖게 됩니다. 부모와 자식 사이의 경쟁 가능성을 염두에 두십시오. 대기 및 퇴장, 퇴장 및 퇴장.



대기는 ptable.lock을 획득함으로써 시작됩니다. 그런 다음 자식을 찾는 프로세스 테이블을 스캔합니다. wait는 현재 프로세스에 자식이 있지만 종료된 자식이 없다는 것을 발견하면 sleep을 호출하여 그 중 하나가 종료될 때까지 기다렸다가(2689) 다시 검색합니다. 여기에서 잠자기 상태에서 해제되는 잠금은 위에서 본 특수한 경우인 ptable.lock입니다.

Exit는 ptable.lock을 획득한 다음 현재 프로세스의 상위 proc(2628)과 동일한 대기 채널에서 잠자는 프로세스를 깨웁니다. 그러한 프로세스가 있으면 대기 중인 부모가 됩니다. exit가 현재 프로세스를 ZOMBIE로 표시하지 않았기 때문에 이것은 시기상조로 보일 수 있지만 안전합니다. wakeup이 부모를 RUNNABLE로 표시할 수 있지만 대기 중인 루프는 exit가 ptable.lock을 해제할 때까지 실행할 수 없습니다. 스케줄러이므로 wait는 종료가 상태를 ZOMBIE(2640)로 설정할 때까지 종료 프로세스를 볼 수 없습니다. 종료 일정을 조정하기 전에 종료 프로세스의 모든 자식을 다시 부모로 지정하여 initproc(2630-2637)에 전달합니다. 마지막으로 exit는 sched를 호출하여 CPU를 포기합니다.

부모 프로세스가 대기 중이면 스케줄러가 결국 실행합니다. sleep에 대한 호출은 ptable.lock을 유지한 상태로 반환됩니다. wait는 프로세스 테이블을 다시 스캔하고 상태 == ZOMBIE인 종료된 자식을 찾습니다. (2634). 자식의 pid를 기록한 다음 struct proc을 정리하여 프로세스와 관련된 메모리를 해제합니다(2668-2676).

자식 프로세스는 종료하는 동안 대부분의 정리를 수행할 수 있지만 부모 프로세스가 p->kstack 및 p->pgdir을 해제하는 것이 중요합니다. 자식이 exit를 실행할 때 스택은 다음과 같이 할당된 메모리에 있습니다. p->kstack이고 자체 페이지 테이블을 사용합니다. swtch(sched를 통해)를 호출하여 자식 프로세스가 마지막으로 실행을 완료한 후에만 해제할 수 있습니다. 이것은 스케줄러 프로시저가 sched를 호출한 스레드의 스택이 아니라 자체 스택에서 실행되는 한 가지 이유입니다.

exit는 프로세스가 자신을 종료할 수 있도록 하는 반면 kill(2875)은 한 프로세스가 다른 프로세스를 종료하도록 요청하도록 합니다. 희생자가 다른 CPU에서 실행 중이거나 커널 데이터 구조를 업데이트하는 도중에 잠자고 있을 수 있기 때문에 kill이 희생자 프로세스를 직접 파괴하기에는 너무 복잡합니다. 이러한 문제를 해결하기 위해 kill은 거의 수행하지 않습니다. 단지 피해자의 p->kill을 설정하고 잠자고 있으면 깨웁니다. 결국 피해자는 커널에 들어가거나 커널을 떠나고, p->killed가 설정된 경우 트랩의 코드가 종료를 호출합니다. 피해자가 사용자 공간에서 실행 중이라면 시스템 호출을 하거나 타이머(또는 다른 장치)가 인터럽트를 걸기 때문에 곧 커널에 들어갈 것입니다.

피해자 프로세스가 sleep 모드에 있으면 깨우기 호출로 인해 피해자 프로세스가 sleep 모드에서 복귀합니다. 이것은 기다리고 있는 조건이 참이 아닐 수 있기 때문에 잠재적으로 위험합니다. 그러나 sleep에 대한 xv6 호출은 항상 sleep이 반환된 후 조건을 다시 테스트하는 while 루프로 래핑됩니다. 잠을 청하는 일부 전화도 p-를 테스트합니다.루프에서 죽이고 현재 활동이 설정되어 있으면 포기합니다. 이것은 그러한 포기가 올바른 경우에만 수행됩니다. 예를 들어 파이프 읽기 및 쓰기 코드(6537)는 killed 플래그가 설정되면 반환됩니다. 결국 코드는 다시 플래그를 확인하고 종료하는 트랩으로 돌아갑니다.

일부 xv6 sleep 루프는 코드가 원자적이어야 하는 다단계 시스템 호출의 중간에 있기 때문에 p->killed를 확인하지 않습니다. IDE 드라이버(4279)가 한 예입니다. 디스크 작업이 파일 시스템을 올바른 상태로 유지하는 데 필요한 쓰기 세트 중 하나일 수 있기 때문에 p->killed를 확인하지 않습니다. 부분 작업 후 정리의 복잡성을 피하기 위해 xv6은 나중에 프로세스를 종료하기 쉬운 특정 시점까지 IDE 드라이버에 있는 프로세스 종료를 지연합니다(예: 완전한 파일 시스템 작업이 완료되고 프로세스가 사용자 공간으로 돌아가려고 함).

