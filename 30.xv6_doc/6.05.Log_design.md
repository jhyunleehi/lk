### 로그 디자인

로그는 디스크 끝의 알려진 고정 위치에 있습니다.
헤더 블록과 업데이트된 블록 복사본('기록된 블록') 시퀀스로 구성됩니다. 

* 헤더 블럭
* 블럭의 복사본(write된 블럭의 복사본) 

헤더 블록에는 기록된 블록마다 하나씩 섹터 번호의 배열이 포함됩니다.
헤더 블록에는 기록된 블록의 개수도 포함됩니다. 

Xv6은 트랜잭션이 커밋될 때 헤더 블록을 기록하지만 그 전에는 기록하지 않고 기록된 블록을 파일 시스템에 복사한 후 카운트를 0으로 설정합니다. 따라서 트랜잭션 중간에 충돌이 발생하면 로그의 헤더 블록에 0이 표시됩니다. 커밋 후 크래시가 발생하면 0이 아닌 카운트가 발생합니다.

각 시스템 호출의 코드는 원자성이어야 하는 쓰기 시퀀스의 시작과 끝을 나타냅니다. 효율성을 위해 그리고 파일 시스템 코드에서 어느 정도 동시성을 허용하기 위해 로깅 시스템은 각 트랜잭션에 대한 여러 시스템 호출의 쓰기를 누적할 수 있습니다. 따라서 단일 커밋에는 여러 개의 완전한 시스템 호출 쓰기가 포함될 수 있습니다. 원자성을 유지하기 위해 로깅 시스템은 진행 중인 파일 시스템 시스템 호출이 없을 때만 커밋합니다.
여러 트랜잭션을 함께 커밋하는 아이디어를 그룹 커밋이라고 합니다.
그룹 커밋을 사용하면 여러 트랜잭션을 동시에 실행할 수 있으며 파일 시스템에서 여러 디스크 작업을 일괄 처리하고 디스크 드라이버에 단일 디스크 작업을 실행할 수 있습니다.
이를 통해 디스크는 블록 쓰기를 영리하게 예약하고 디스크 대역폭의 속도로 쓸 수 있습니다. Xv6의 IDE 드라이버는 일괄 처리를 지원하지 않지만 xv6의 파일 시스템 설계는 일괄 처리를 지원합니다.

Xv6은 로그를 보관하기 위해 디스크에 고정된 공간을 할당합니다. 트랜잭션에서 시스템 호출에 의해 작성된 총 블록 수는 해당 공간에 맞아야 합니다.

이것은 두 가지 결과를 낳습니다. 로그에 있는 공간보다 더 많은 개별 블록을 쓰기 위해 단일 시스템 호출을 허용할 수 없습니다. 이것은 대부분의 시스템 호출에서 문제가 되지 않지만 그 중 두 가지는 잠재적으로 많은 블록을 쓸 수 있습니다. 쓰기 및 연결 해제.

큰 파일 쓰기는 많은 데이터 블록과 많은 비트맵 블록과 inode 블록을 쓸 수 있습니다. 큰 파일의 연결을 해제하면 많은 비트맵 블록과 inode를 쓸 수 있습니다.

Xv6의 쓰기 시스템 호출은 큰 쓰기를 로그에 맞는 여러 개의 작은 쓰기로 나눕니다. 실제로 xv6 파일 시스템은 하나의 비트맵 블록만 사용하기 때문에 링크 해제는 문제를 일으키지 않습니다. 제한된 로그 공간의 다른 결과는 시스템 호출의 쓰기가 로그에 남아 있는 공간에 맞는 것이 확실하지 않으면 로깅 시스템이 시스템 호출을 시작하는 것을 허용할 수 없다는 것입니다.