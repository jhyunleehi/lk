## Code: Sleep and wakeup

xv6의 sleep및 깨우기 구현을 살펴보겠습니다.
기본 아이디어는 sleep 모드에서 현재 프로세스를 SLEEPING으로 표시한 다음 sched를 호출하여 프로세서를 해제하는 것입니다. wakeup은 주어진 대기 채널에서 잠자는 프로세스를 찾아 RUNNABLE로 표시합니다.



sleep(2803)은 몇 가지 온전성 검사로 시작됩니다. 현재 프로세스(2805)가 있어야 하고 sleep이 잠금(2808-2809)을 통과해야 합니다. 그런 다음 sleep은 pt-able.lock(2818)을 얻습니다. 이제 sleep 모드로 전환되는 프로세스는 ptable.lock과 lk를 모두 보유합니다.
호출자(예: recv)에서 lk를 유지하는 것이 필요했습니다. 다른 프로세스(예: 하나의 send 실행)가 호출 wakeup(chan)을 시작할 수 없도록 했습니다. 이제 sleep이 ptable.lock을 보유하고 있으므로 lk를 해제하는 것이 안전합니다. 다른 프로세스가 wakeup(chan)에 대한 호출을 시작할 수 있지만 ptable.lock을 획득할 수 있을 때까지 wakeup이 실행되지 않으므로 sleep이 완료될 때까지 기다려야 합니다. 잠에서 깨어나지 못하도록 잠드는 과정.



사소한 문제가 있습니다. lk가 &ptable.lock과 같으면 sleep이 교착 상태가 되어 이를 &ptable.lock으로 획득한 다음 lk로 해제합니다. 이 경우 sleep은 획득과 해제를 서로 취소하는 것으로 간주하고 완전히 건너뜁니다(2817). 예를 들어, wait(2653)는 &ptable.lock을 사용하여 sleep을 호출합니다.
이제 sleep이 ptable.lock을 보유하고 다른 것은 보유하지 않으므로 sleep 채널을 기록하고 프로세스 상태를 변경하고 sched(2823-2825)를 호출하여 프로세스를 잠자기 상태로 만들 수 있습니다.

사소한 문제가 있습니다. lk가 &ptable.lock과 같으면 sleep이 교착 상태가 되어 이를 &ptable.lock으로 획득한 다음 lk로 해제합니다. 이 경우 sleep은 획득과 해제를 서로 취소하는 것으로 간주하고 완전히 건너뜁니다(2817). 예를 들어, wait(2653)는 &ptable.lock을 사용하여 sleep을 호출합니다.
이제 sleep이 ptable.lock을 보유하고 다른 것은 보유하지 않으므로 sleep 채널을 기록하고 프로세스 상태를 변경하고 sched(2823-2825)를 호출하여 프로세스를 잠자기 상태로 만들 수 있습니다.



나중에 어떤 시점에서 프로세스는 wakeup(chan)을 호출합니다. Wakeup(2853)은 pt-able.lock을 획득하고 실제 작업을 수행하는 wakeup1을 호출합니다. wakeup이 ptable.lock을 유지하는 것은 프로세스 상태를 조작하고 있기 때문에 그리고 방금 보았듯이 ptable.lock이 sleep과 wakeup이 서로를 놓치지 않도록 하기 때문에 중요합니다.
Wakeup1은 때때로 스케줄러가 이미 ptable.lock을 보유하고 있을 때 깨우기를 실행해야 하기 때문에 별도의 함수입니다. 우리는 나중에 이것의 예를 보게 될 것입니다. Wakeup1(2853)은 프로세스 테이블을 반복합니다. 일치하는 채널이 있는 SLEEPING 상태의 프로세스를 찾으면 해당 프로세스의 상태를 RUNNABLE로 변경합니다. 다음에 스케줄러가 실행되면 프로세스를 실행할 준비가 되었음을 알 수 있습니다.



웨이크업은 항상 웨이크업 조건이 무엇이든 보호하는 잠금을 유지하면서 호출되어야 합니다. 위의 예에서 잠금은 q->lock입니다. 슬리핑 프로세스가 웨이크업을 놓치지 않는 이유에 대한 완전한 주장은 항상 상태를 확인하기 전부터 슬립 상태가 될 때까지 조건이나 ptable.lock 또는 둘 모두에 대한 잠금을 유지한다는 것입니다. 웨이크업은 두 잠금을 모두 유지한 상태에서 실행되기 때문에 잠재적인 sleeper가 상태를 확인하기 전에 또는 잠재적인 sleeper가 스스로를 sleep 모드로 전환한 후 깨우기를 실행해야 합니다.



여러 프로세스가 동일한 채널에서 잠자기 상태인 경우가 있습니다. 예를 들어 파이프에서 읽기를 시도하는 둘 이상의 프로세스. 깨우라고 한 번만 불러도 모두 깨울 것입니다. 그들 중 하나가 먼저 실행되고 sleep이 호출된 잠금을 획득하고 (파이프의 경우) 파이프에서 대기 중인 모든 데이터를 읽습니다.
다른 프로세스는 깨어났음에도 불구하고 읽을 데이터가 없음을 알게 됩니다. 그들의 관점에서 기상은 '가짜'였고, 그들은 다시 자야 했습니다. 이러한 이유로 sleep은 항상 조건을 확인하는 루프 내에서 호출됩니다.
수면 및 기상 호출자는 상호 편리한 번호를 채널로 사용할 수 있습니다. 실제로 xv6은 디스크 버퍼와 같이 대기와 관련된 커널 데이터 구조의 주소를 자주 사용합니다. sleep/wakeup을 두 번 사용하여 실수로 같은 채널을 선택해도 해가 되지 않습니다. 그들은 가짜 깨우기를 볼 것이지만 설명된 대로 반복됩니다.
위는 이 문제를 용인할 것입니다. sleep/wakeup의 매력 중 대부분은 가볍고(수면 채널 역할을 하기 위해 특별한 데이터 구조를 만들 필요가 없음) 간접 계층을 제공한다는 것입니다(호출자는 상호 작용하는 특정 프로세스를 알 필요가 없습니다).