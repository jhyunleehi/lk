## Multiplexing

Xv6은 두 가지 상황에서 각 프로세서를 한 프로세스에서 다른 프로세스로 전환하여 다중화합니다. 

* 첫째, xv6의 슬립 및 웨이크업 메커니즘은 프로세스가 장치 또는 파이프 I/O가 완료되기를 기다리거나 자식이 종료될 때까지 기다리거나 슬립 시스템 호출을 기다릴 때 전환됩니다. 
* 둘째, xv6은 프로세스가 사용자 명령을 실행할 때 주기적으로 강제로 전환합니다. 

이 멀티플렉싱은 xv6이 메모리 할당자와 하드웨어 페이지 테이블을 사용하여 각 프로세스에 고유한 메모리가 있다는 환상을 만드는 것처럼 각 프로세스에 자체 CPU가 있다는 환상을 만듭니다.



멀티플렉싱을 구현하는 데는 몇 가지 문제가 있습니다.

* 첫째, 한 프로세스에서 다른 프로세스로 전환하는 방법은 무엇입니까? Xv6은 컨텍스트 전환의 표준 메커니즘을 사용합니다. 아이디어는 간단하지만 구현은 시스템에서 가장 불투명한 코드 중 일부입니다.
* 둘째, 컨텍스트 스위칭을 투명하게 수행하는 방법은 무엇입니까? Xv6은 타이머 인터럽트 핸들러를 사용하여 컨텍스트 스위치를 구동하는 표준 기술을 사용합니다.
* 셋째, 많은 CPU가 동시에 프로세스 간에 전환될 수 있으며 경합을 방지하기 위한 잠금 계획이 필요합니다.
* 넷째, 프로세스가 메모리를 종료하고 다른 리소스를 해제해야 하지만 이 모든 작업을 스스로 수행할 수 없을 때 (예를 들어) 여전히 사용하는 동안 자체 커널 스택을 해제할 수 없기 때문입니다. Xv6은 이러한 문제를 가능한 한 간단하게 해결하려고 하지만 그럼에도 불구하고 결과 코드는 까다롭습니다.



xv6은 프로세스가 서로 조정할 수 있는 방법을 제공해야 합니다. 예를 들어, 부모 프로세스는 자식 중 하나가 종료될 때까지 기다려야 하거나 파이프를 읽는 프로세스는 파이프를 쓰는 다른 프로세스를 기다려야 할 수 있습니다. 원하는 이벤트가 발생했는지 여부를 반복적으로 확인하여 대기 프로세스가 CPU를 낭비하게 만드는 대신 xv6은 프로세스가 CPU를 포기하고 이벤트를 기다리면서 슬립을 허용하고 다른 프로세스가 첫 번째 프로세스를 깨우도록 합니다. 이벤트 알림이 손실되는 레이스를 방지하려면 주의가 필요합니다. 이러한 문제와 해결 방법의 예로서 이 장에서는 파이프의 구현을 검토합니다.

