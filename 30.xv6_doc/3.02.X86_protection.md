## x86 protection

x86에는 0(최대 권한)에서 3(최소 권한)까지의 4가지 보호 수준이 있습니다.

실제로 대부분의 운영 체제는 0과 3의 두 가지 수준만 사용하며, 이를 각각 커널 모드와 사용자 모드라고 합니다. x86이 명령어를 실행하는 현재 권한 수준은 CPL 필드의 %cs 레지스터에 저장됩니다.

​                

중요한 것은 CPL 보다 INT 발생시키는 것의 권한이 낮을 때 SS와 ESP의 설정이 변경된다는 것이다. 이렇게 해서 보호 할 수 있는 것이 무엇인지는 잘 모르겠지만. 

x86에서 인터럽트 핸들러는 IDT(인터럽트 디스크립터 테이블)에 정의됩니다  .x86에서 인터럽트 핸들러는 IDT(인터럽트 디스크립터 테이블)에 정의됩니다.  IDT에는 해당 인터럽트를 처리할 때 사용할 %cs 및 %eip를 각각 제공하는 256개의 항목이 있습니다.

x86에서 시스템 호출을 수행하기 위해 프로그램은 int n 명령을 호출합니다. 여기서 n은 IDT에 대한 인덱스를 지정합니다. int 명령어는 다음 단계를 수행합니다.

* IDT에서 n번째 Descriptor 를 가져옵니다. 여기서 n은 인터럽트 번호 입니다.
* %cs의 CPL이 <= DPL인지 확인합니다. 여기서 DPL은 설명자의 권한 수준입니다. (current previlege Level 이 IDT에 정의된 Descriptor Previlege Level 보다 작은지 확인한다)
* %esp 및 %ss를 CPU 내부 레지스터에 저장하되 대상 세그먼트 선택기의 PL < CPL인 경우에만 저장합니다.
*  Load %ss and %esp from a task segment descriptor.
* Push %ss.
* Push %esp.
* Push %eflags.
* Push %cs.
* Push %eip.
* Clear some bits of %eflags.
* Set %cs and %eip to the values in the descriptor

##### int struction 이후 kernel stack

![image-20220202102935757](C:\code\lk\30.xv6_doc\img\image-20220202102935757.png)



int 명령어는 복잡한 명령어이며 이 모든 작업이 필요한지 궁금할 수 있습니다. 

CPL <= DPL을 확인하면 커널이 일부 권한 수준에 대해 시스템을 금지할 수 있습니다. 예를 들어 사용자 프로그램이 int 명령어를 성공적으로 실행하려면 DPL이 3이어야 합니다.

사용자 프로그램에 적절한 권한이 없으면 int 명령어는 int 13을 생성하며 이는 일반적인 보호 오류입니다.

다른 예로, int 명령어는 사용자 스택을 사용하여 값을 저장할 수 없습니다. 사용자가 적절한 스택을 설정하지 않아 하드웨어가 커널 모드에서 설정된 작업 세그먼트에 지정된 스택을 사용하도록 할 수 있기 때문입니다.



#####  CPU의 특권 레벨

* 0 ~ 3 으로 4가지로 구성되어 있습니다. 그중 0과 3의 2개의 레벨만을 사용합니다.
* x86에는 0(최대 권한)에서 3(최소 권한)까지의 4가지 보호 수준이 있다. (OK)

#####  CPL, DPL, RPL

1. CPL ( Current Privilege Level )   : CPL은 현재 실행되고 있는 태스크의 특권 레벨로, CS, SS 셀렉터 레지스터 0, 1번째 비트에 있는 수입니다. 

2. DPL ( Description Privilege Level )   : DPL은 디스크립터에 기재된 DPL 값이고 2비트로 표현됩니다. 디스크립터를 통한 세그먼트 영역으로의 모든 접근에서 항상 CPL 과 DPL의 관계가 체크됩니다.

3. RPL ( Requested Privilege Level )   : RPL은 단어가 암시하는 바와 같이 누가 요구했는가를 나타내는 값입니다. 특권 레벨 3에서 불려졌다는 표시를 해두면 특권 레벨 0의 데이터는 건드리지 못 합니다.



![image-20220202104059453](img/image-20220202104059453.png)