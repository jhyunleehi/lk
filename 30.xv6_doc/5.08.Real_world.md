## Real world

xv6 스케줄러는 각 프로세스를 차례로 실행하는 간단한 스케줄링 정책을 구현합니다. 이 정책을 라운드 로빈이라고 합니다. 실제 운영 체제는 예를 들어 프로세스가 우선 순위를 갖도록 허용하는 보다 정교한 정책을 구현합니다. 실행 가능한 낮은 우선 순위 스레드보다 실행 가능한 높은 우선 순위 프로세스가 스케줄러에 의해 선호된다는 아이디어입니다. 이러한 정책은 종종 경쟁적인 목표가 있기 때문에 빠르게 복잡해질 수 있습니다. 예를 들어, 운영은 공정성과 높은 처리량을 보장하기를 원할 수도 있습니다. 또한 복잡한 정책은 의도하지 않은 결과를 초래할 수 있습니다.
우선 순위 반전 및 호송과 같은 상호 작용. 우선 순위 버전은 낮은 우선 순위와 높은 우선 순위 프로세스가 잠금을 공유할 때 발생할 수 있으며, 낮은 우선 순위 프로세스가 잠금을 획득하면 높은 우선 순위 프로세스가 실행되지 않을 수 있습니다. 많은 높은 우선 순위 프로세스가 공유 잠금을 획득하는 낮은 우선 순위 프로세스를 기다리고 있을 때 긴 호송이 형성될 수 있습니다. 호송대가 형성되면 장기간 지속될 수 있습니다. 이러한 종류의 문제를 방지하려면 정교한 스케줄러에 추가 메커니즘이 필요합니다.



잠자기와 깨우기는 간단하고 효과적인 동기화 방법이지만 다른 많은 방법이 있습니다. 이들 모두의 첫 번째 과제는 장의 시작 부분에서 보았던 '잊어버린 기상' 문제를 피하는 것입니다. 원래 Unix 커널의 슬립은 단순히 인터럽트를 비활성화했는데 Unix가 단일 CPU 시스템에서 실행되었기 때문에 충분했습니다.
xv6은 다중 프로세서에서 실행되기 때문에 절전 모드에 명시적 잠금을 추가합니다. FreeBSD의 msleep도 같은 접근 방식을 취합니다. Plan 9의 sleep은 잠자기 직전에 일정 잠금을 유지하면서 실행되는 콜백 함수를 사용합니다. 이 기능은 기상 상태를 놓치는 것을 방지하기 위해 마지막 순간에 수면 상태를 확인하는 역할을 합니다. Linux 커널의 절전 모드는 대기 채널 대신 명시적 프로세스 대기열을 사용합니다. 대기열에는 자체 내부 잠금이 있습니다.



일치하는 chan이 있는 프로세스에 대해 웨이크업 시 전체 프로세스 목록을 검색하는 것은 비효율적입니다. 더 나은 솔루션은 절전 모드와 절전 모드 해제 모두에서 해당 구조에서 대기 중인 프로세스 목록을 보유하는 데이터 구조로 chan을 교체하는 것입니다. 랑데뷰 포인트 또는 랑데즈를 구성하는 플랜 9의 슬립 및 모닝콜. 많은 스레드 라이브러리는 조건 변수와 동일한 구조를 참조합니다. 그 맥락에서, 작업 슬립 및 웨이크업은 대기 및 신호라고 합니다. 이러한 모든 메커니즘은 동일한 특징을 공유합니다. 절전 상태는 절전 중에 원자적으로 드롭된 일종의 잠금에 의해 보호됩니다.

웨이크업을 구현하면 특정 채널에서 대기하고 있는 모든 프로세스를 깨우고 많은 프로세스가 해당 특정 채널을 기다리고 있는 경우일 수 있습니다. 운영 체제는 이러한 모든 프로세스를 예약하고 절전 상태를 확인하기 위해 경쟁합니다. 이런 식으로 행동하는 프로세스를 천둥 무리라고 부르며 피하는 것이 가장 좋습니다. 대부분의 조건 변수에는 웨이크업을 위한 두 가지 기본 요소가 있습니다. 하나의 프로세스를 깨우는 신호와 대기 중인 모든 프로세스를 깨우는 브로드캐스트입니다.

세마포어는 또 다른 일반적인 조정 메커니즘입니다. 세마포어는 증가 및 감소(또는 상향 및 하향)의 두 가지 연산이 있는 정수 값입니다. 세마포어를 증가시키는 것은 가능하지만 세마포어 값은 허용되지 않습니다.
0 아래로 떨어짐: 0 세마포어의 감소는 다른 프로세스가 세마포어를 증가시킬 때까지 휴면하고, 그 다음 두 작업이 취소됩니다. 정수 값은 일반적으로 파이프 버퍼에서 사용할 수 있는 바이트 수 또는 프로세스에 있는 좀비 자식 수와 같은 실제 수에 해당합니다. 추상화의 일부로 명시적 카운트를 사용하면 '미스된 웨이크업'' 문제를 피할 수 있습니다. 발생한 웨이크업 수에 대한 명시적 카운트가 있습니다. 카운트는 또한 가짜 기상 및 천둥 같은 무리 문제를 방지합니다.

프로세스를 종료하고 정리하면 xv6에서 훨씬 더 복잡해집니다. 대부분의 운영 체제에서 이는 훨씬 더 복잡합니다. 예를 들어 피해자 프로세스가 커널 내부 깊숙이 잠들어 있을 수 있고 스택 해제에는 많은 작업이 필요하기 때문입니다.
신중한 프로그래밍. 많은 운영 체제는 longjmp와 같은 예외 처리를 위한 명시적 메커니즘을 사용하여 스택을 해제합니다. 또한 대기 중인 이벤트에도 불구하고 잠자는 프로세스를 깨울 수 있는 다른 이벤트가 있습니다.
아직 일어나지 않았기 때문입니다. 예를 들어, 프로세스가 잠자기 상태일 때 다른 프로세스가 신호를 보낼 수 있습니다. 이 경우 프로세스는 중단된 시스템 호출에서 -1 값과 EINTR로 설정된 오류 코드로 반환됩니다. 애플리케이션은 이러한 값을 확인하고 수행할 작업을 결정할 수 있습니다. Xv6은 신호를 지원하지 않으며 이러한 복잡성이 발생하지 않습니다.

kill에 대한 Xv6의 지원은 완전히 만족스럽지 않습니다. p->killed를 확인해야 하는 슬립 루프가 있습니다. 관련된 문제는 p->killed를 확인하는 수면 루프의 경우에도 sleep과 kill 사이에 경쟁이 있다는 것입니다. 후자는 p->killed를 설정하고 희생자의 루프가 p->killed를 확인한 직후 그러나 sleep을 호출하기 전에 희생자를 깨우려고 할 수 있습니다. 이 문제가 발생하면 피해자는 기다리고 있는 조건이 발생할 때까지 p->killed를 알아차리지 못합니다. 이것은 꽤 나중에(예: IDE 드라이버가 피해자가 기다리고 있는 디스크 블록을 반환할 때) 또는 전혀(예: 피해자가 콘솔에서 입력을 기다리고 있지만 사용자가 아무 입력도 입력하지 않은 경우) ).