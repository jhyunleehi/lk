### 로깅 계층

파일 시스템 설계에서 가장 흥미로운 문제 중 하나는 disk crash recovery 입니다. (가장 고민 거리라는 뜻)

이러한 문제는 

* 파일 시스템들이 디스크에 multiple write를 가지고 있기 때문이다. 
* multiple write 하는 작업 단위의 실패 (crah)하게 되면 디스크 상의 파일 시스템은 일관성이 없는 무결성이 손상된 상태로 남아 있게 된다. 

예를 들어, 디스크 쓰기 순서에 따라 디렉토리 항목에서 inode는 삭제하였지만 실제 inode는 남아 있는 상태이거나, inode는 삭제되었는데 디스크 엔트리 항목에는 남아 있게되는 경우가 발생할 수 있다.

* 디렉토리에서 inode 엔트리 지웠으나 inode는 남아 있는 경우 (순한 맛)
* 디렉토리에는 inode 엔트리 있으나 inode는 지워진 경우 (매운맛)

해제된 inode를 참조하는 디렉토리 항목은 재부팅 후 심각한 문제를 일으킬 수 있습니다.

##### 로깅 방법

Xv6은 단순 버전의 로깅으로 파일 시스템 작업 중 충돌 문제를 해결합니다. 

* xv6 시스템 호출은 디스크 상의 파일 시스템 데이터 구조를 직접 쓰지 않습니다. 
* 대신 디스크의 로그에 만들고자 하는 모든 디스크 쓰기에 대한 description을 기록 한다.

System call이 모든 쓰기를 로깅 완료하면,  로그에 완전한 작업이 포함되어 있음을 나타내는 특수 커밋 레코드를 디스크에 쓴다.

그 시점에서 시스템 호출은 디스크 상의 파일 시스템 데이터 구조에 쓰기를 복사합니다.

이러한 쓰기가 완료된 후 시스템 호출은 디스크의 로그를 지웁니다. 

##### 복구 절차

시스템이 충돌하고 재부팅해야 하는 경우 파일 시스템 코드는 프로세스를 실행하기 전에 다음과 같이 충돌에서 복구합니다. 

로그에 완전한 작업이 포함된 것으로 표시된 경우 복구 코드는 디스크 상의 파일 시스템에서 해당 기록이 속하는 위치에 쓰기를 복사합니다. 로그가 완전한 작업을 포함하는 것으로 표시되지 않은 경우 복구 코드는 로그를 무시합니다. 복구 코드는 로그를 지우면 완료됩니다.



##### log가 disk crash 해결하는 이유

xv6의 로그가 파일 시스템 작동 중 crach 문제를 해결하는 이유는 무엇입니까? 

작업이 커밋되기 전에 충돌이 발생하면, 디스크 상에 로그에는 완료된 것으로 표시되지 않는다.  복구 코드가 이를 무시하며 디스크 상태는 작업이 시작되지도 않은 것처럼 됩니다.

작업이 커밋된 후 crash가  발생하면 복구는 작업의 모든 쓰기를 재생하며,  작업이 디스크 데이터 구조에 쓰기를 시작한 경우 이를 반복할 수 있습니다.

두 경우 모두 로그는 충돌과 관련하여 작업을 원자성으로 만듭니다. 복구 후 작업의 모든 쓰기가 디스크에 나타나거나 아무 것도 나타나지 않습니다.