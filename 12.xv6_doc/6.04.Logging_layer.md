### 로깅 계층

파일 시스템 설계에서 가장 흥미로운 문제 중 하나는 충돌 복구입니다. 많은 파일 시스템 작업이 디스크에 대한 다중 쓰기를 포함하고 쓰기의 하위 집합 이후 충돌로 인해 디스크 상의 파일 시스템이 일관성 없는 상태로 남을 수 있기 때문에 문제가 발생합니다.
예를 들어, 디스크 쓰기 순서에 따라, 파일 삭제 중 충돌은 여유 inode를 가리키는 디렉토리 항목을 남기거나 할당되었지만 참조되지 않은 inode를 남길 수 있습니다.
후자는 비교적 온건하지만 해제된 inode를 참조하는 디렉토리 항목은 재부팅 후 심각한 문제를 일으킬 수 있습니다.

Xv6은 단순 버전의 로깅으로 파일 시스템 작업 중 충돌 문제를 해결합니다. xv6 시스템 호출은 디스크 상의 파일 시스템 데이터 구조를 직접 쓰지 않습니다. 대신 디스크의 로그에 만들고자 하는 모든 디스크 쓰기에 대한 설명을 넣습니다. 시스템 호출이 모든 쓰기를 기록하면 로그에 완전한 작업이 포함되어 있음을 나타내는 특수 커밋 레코드를 디스크에 씁니다. 그 시점에서 시스템 호출은 디스크 상의 파일 시스템 데이터 구조에 쓰기를 복사합니다.

이러한 쓰기가 완료된 후 시스템 호출은 디스크의 로그를 지웁니다. 시스템이 충돌하고 재부팅해야 하는 경우 파일 시스템 코드는 프로세스를 실행하기 전에 다음과 같이 충돌에서 복구합니다. 로그에 완전한 작업이 포함된 것으로 표시된 경우 복구 코드는 디스크 상의 파일 시스템에서 해당 기록이 속하는 위치에 쓰기를 복사합니다. 로그가 완전한 작업을 포함하는 것으로 표시되지 않은 경우 복구 코드는 로그를 무시합니다. 복구 코드는 로그를 지우면 완료됩니다.

xv6의 로그가 파일 시스템 작동 중 충돌 문제를 해결하는 이유는 무엇입니까? 작업이 커밋되기 전에 충돌이 발생하면 디스크 로그온이 완료된 것으로 표시되지 않고 복구 코드가 이를 무시하며 디스크 상태는 작업이 시작되지도 않은 것처럼 됩니다.
작업이 커밋된 후 충돌이 발생하면 복구는 작업의 모든 쓰기를 재생하며 작업이 디스크 데이터 구조에 쓰기를 시작한 경우 이를 반복할 수 있습니다.
두 경우 모두 로그는 충돌과 관련하여 작업을 원자성으로 만듭니다. 복구 후 작업의 모든 쓰기가 디스크에 나타나거나 아무 것도 나타나지 않습니다.