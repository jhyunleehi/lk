## Memory Ordering

이 장에서는 프로세서가 프로그램에 나타나는 순서대로 명령을 시작하고 완료한다고 가정했습니다. 그러나 많은 프로세서가 더 높은 성능을 달성하기 위해 명령을 실행합니다. 

그러나 많은 프로세서가 더 높은 성능을 달성하기 위해 명령을 실행합니다. 명령어가 완료하는 데 많은 사이클이 걸리는 경우 프로세서는 다른 명령어와 겹치고 프로세서 정지를 방지할 수 있도록 일찍 명령어를 발행할 수 있습니다.

예를 들어, 프로세서는 일련의 명령어 A와 B가 서로 의존하지 않는다는 것을 알아차리고 프로세서가 A를 완료할 때 완료되도록 A보다 먼저 명령어 B를 시작할 수 있습니다.
그러나 동시성은 이 재정렬을 소프트웨어에 노출시켜 잘못된 동작으로 이어질 수 있습니다.
예를 들어 xchg를 사용하는 대신 릴리스가 lk->locked에 0을 할당하면 어떻게 되는지 궁금할 수 있습니다. 이 질문에 대한 답은 불명확합니다. 다른 세대의 x86 프로세서가 메모리 순서에 대해 서로 다른 보장을 하기 때문입니다.
lk->locked=0인 경우 popcli 이후에 다시 정렬되도록 허용된 경우 잠금이 해제되기 전에 다른 스레드에 대한 인터럽트가 활성화되기 때문에 획득이 중단될 수 있습니다.
메모리 순서에 대해 불명확한 프로세서 사양에 의존하는 것을 피하기 위해 xv6은 위험을 감수하지 않고 프로세서가 재정렬하지 않도록 보장해야 하는 xchg를 사용합니다.

