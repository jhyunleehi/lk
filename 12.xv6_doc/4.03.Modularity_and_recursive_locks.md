## 모듈화 및 재귀 잠금

시스템 디자인은 깨끗하고 모듈화된 추상화를 위해 추구한다. 

호출자가 특정 기능을 구현하는 방법을 호출자가 알 필요가 없을 때 가장 좋습니다. (있으나 없는 것 처럼) 

잠금 장치는 이러한 모듈성을 방해합니다. 

예를 들어 CPU가 특정 잠금을 보유하고 있으면 해당 잠금을 다시 획득하려고 시도하는 함수 f를 호출할 수 없습니다. 호출자는 f가 반환될 때까지 잠금을 해제할 수 없기 때문에 f가 동일한 잠금을 획득하려고 시도하면 영원히 또는 교착 상태.

#### 재귀적 Lock

일반적으로 호출자와 수신자가 사용하는 잠금을 숨길 수 있는 투명한 솔루션은 없습니다. 

보통 투명하지만 불만족스러운 솔루션 중 하나는 호출자가 호출자가 이미 보유하고 있는 잠금을 다시 획득할 수 있도록 하는 것이 recursive locks  이다. 

이 솔루션의 문제는 재귀 잠금을 사용하여 불변성을 보호할 수 없다는 것입니다. 

위에서 획득(&listlock)을 호출한 삽입 후에는 잠금을 유지하는 다른 함수가 없고 목록 작업의 중간에 다른 함수가 없으며 가장 중요한 것은 모든 목록 불변성이 유지된다는 점을 가정할 수 있습니다. 

재귀적 잠금이 있는 시스템에서 삽입은 획득을 호출한 후 아무 것도 가정할 수 없습니다.

아마도 삽입 호출자 중 하나가 이미 잠금을 보유하고 목록 데이터 구조를 편집하는 중에 있었기 때문에 획득이 성공했을 수 있습니다. 불변성이 유지되거나 그렇지 않을 수도 있습니다. 목록은 더 이상 그들을 보호하지 않습니다. 

잠금은 서로 다른 CPU를 보호하는 것만큼 호출자와 호출 수신자를 서로 보호하는 데 중요합니다. 재귀 잠금은 해당 속성을 포기합니다.
이상적인 투명 솔루션이 없기 때문에 잠금을 함수 사양의 일부로 고려해야 합니다. 

프로그래머는 f가 필요로 하는 잠금을 유지하는 동안 함수가 f를 호출하지 않도록 조정해야 합니다. 