## Real world

실제 운영 체제의 버퍼 캐시는 xv6보다 훨씬 더 복잡하지만 디스크에 대한 액세스를 캐시하고 동기화하는 동일한 두 가지 목적을 수행합니다. Xv6의 버퍼 캐시는 V6과 마찬가지로 간단한 LRU(Least Latest Use) 축출 정책을 사용합니다. 구현할 수 있는 더 복잡한 정책이 많이 있으며, 각각은 일부 작업 부하에는 좋고 다른 작업에는 좋지 않습니다. 보다 효율적인 LRU 캐시는 연결 목록을 제거하는 대신 조회를 위한 해시 테이블과 LRU 제거를 위한 힙을 사용합니다.
최신 버퍼 캐시는 일반적으로 가상 메모리 시스템과 통합되어 메모리 매핑된 파일을 지원합니다.
Xv6의 로깅 시스템은 비효율적입니다. 커밋은 파일 시스템 호출과 동시에 발생할 수 없습니다. 시스템은 블록의 몇 바이트만 변경되더라도 전체 블록을 기록합니다. 한 번에 한 블록씩 동기식 로그 쓰기를 수행하며 각 쓰기 작업에는 전체 디스크 회전 시간이 필요할 수 있습니다. 실제 로깅 시스템은 이러한 모든 문제를 해결합니다.
로깅은 충돌 복구를 제공하는 유일한 방법이 아닙니다. 초기 파일 시스템은 재부팅 시 청소기를 사용하여(예: UNIX fsck 프로그램) 모든 파일과 디렉토리, 블록 및 inode 여유 목록을 검사하여 불일치를 찾고 해결했습니다.
큰 파일 시스템의 경우 청소에 몇 시간이 걸릴 수 있으며 원본 시스템 호출을 원자성으로 만드는 방식으로 불일치를 해결할 수 없는 상황이 있습니다. 로그로부터의 복구는 훨씬 빠르며 충돌에 직면하여 시스템 호출이 원자성(atomic)이 되도록 합니다.
Xv6은 초기 UNIX와 동일한 기본 디스크 상의 inode 및 디렉토리 레이아웃을 사용합니다.

이 계획은 수년 동안 현저하게 지속되었습니다.
BSD의 UFS/FFS와 Linux의 ext2/ext3는 본질적으로 동일한 데이터 구조를 사용합니다. 파일 시스템 레이아웃에서 가장 비효율적인 부분은 디렉토리로, 각 조회 동안 모든 디스크 블록에 대한 선형 스캔이 필요합니다. 이는 디렉토리가 디스크 블록이 몇 개일 때 합리적이지만 많은 파일을 보유하는 디렉토리에는 비용이 많이 듭니다. Microsoft Windows의 NTFS, Mac OS X의 HFS, Solaris의 ZFS 등은 디렉토리를 디스크 상의 균형 잡힌 블록 트리로 구현합니다. 이것은 복잡하지만 대수 시간 디렉토리 조회를 보장합니다.

Xv6은 디스크 오류에 대해 순진합니다. 디스크 작업이 실패하면 xv6 패닉이 발생합니다. 이것이 합리적인지 여부는 하드웨어에 따라 다릅니다. 운영 체제가 중복성을 사용하여 디스크 오류를 마스킹하는 특수 하드웨어 위에 있는 경우 운영 체제에서 오류를 너무 자주 확인하므로 패닉 상태가 괜찮을 것입니다. 반면에 일반 디스크를 사용하는 운영 체제는 오류를 예상하고 이를 보다 원활하게 처리하여 한 파일의 블록 손실이 나머지 파일 시스템의 사용에 영향을 미치지 않도록 해야 합니다.

Xv6에서는 파일 시스템이 하나의 디스크 장치에 맞고 크기가 변경되지 않아야 합니다. 대용량 데이터베이스와 멀티미디어 파일로 인해 스토리지 요구 사항이 더욱 높아짐에 따라 운영 체제에서는 "파일 시스템당 하나의 디스크" 병목 현상을 제거하는 방법을 개발하고 있습니다. 기본 접근 방식은 여러 디스크를 단일 논리 디스크로 결합하는 것입니다.

RAID와 같은 하드웨어 솔루션이 여전히 가장 인기가 있지만 현재 추세는 소프트웨어에서 이러한 논리를 최대한 구현하는 방향으로 이동하고 있습니다.
이러한 소프트웨어 구현은 일반적으로 즉석에서 디스크를 추가하거나 제거하여 논리 장치를 늘리거나 줄이는 것과 같은 풍부한 기능을 허용합니다. 물론, 즉석에서 확장하거나 축소할 수 있는 스토리지 계층에는 동일한 작업을 수행할 수 있는 파일 시스템이 필요합니다. xv6에서 사용하는 고정 크기의 inode 블록 배열은 이러한 환경에서 제대로 작동하지 않습니다.
파일 시스템에서 디스크 관리를 분리하는 것이 가장 깔끔한 디자인일 수 있지만 둘 사이의 복잡한 인터페이스로 인해 Sun의 ZFS와 같은 일부 시스템에서는 이 둘을 결합하게 되었습니다.

Xv6의 파일 시스템에는 현대 파일 시스템의 다른 많은 기능이 부족합니다. 예를 들어 스냅샷 및 증분 백업에 대한 지원이 부족합니다.
최신 Unix 시스템을 사용하면 명명된 파이프, 네트워크 연결, 원격으로 액세스되는 네트워크 파일 시스템, 모니터링 및 제어 인터페이스(예: /proc)와 같은 온디스크 스토리지와 동일한 시스템 호출로 다양한 종류의 리소스에 액세스할 수 있습니다.

fileread 및 filewrite에서 xv6의 if 문 대신 이러한 시스템은 일반적으로 각 열린 파일에 작업당 하나씩 함수 포인터 테이블을 제공하고 함수 포인터를 호출하여 해당 inode의 호출 구현을 호출합니다. 네트워크 파일 시스템 및 사용자 수준 파일 시스템 기능 제공