## Real world

이 부록에 설명된 부트 로더는 C 코드를 컴파일할 때 사용된 최적화에 따라 약 470바이트의 기계어 코드로 컴파일됩니다. 그 작은 공간에 맞추기 위해 xv6 부트 로더는 커널이 섹터 1에서 연속적으로 시작하여 부트 디스크에 기록되었다는 주요 단순화 가정을 합니다.
보다 일반적으로 커널은 인접하지 않거나 네트워크를 통해 로드되는 일반 파일 시스템에 저장됩니다.
 이러한 복잡성으로 인해 부트 로더가 다양한 디스크 및 네트워크 컨트롤러를 구동하고 다양한 파일 시스템 및 네트워크 프로토콜을 이해할 수 있어야 합니다. 즉, 부트로더 자체가 작은 운영 체제여야 합니다. 이러한 복잡한 부트 로더는 확실히 512바이트에 맞지 않기 때문에 대부분의 PC 운영 체제는 2단계 부팅 프로세스를 사용합니다. 첫째, 이 부록에 있는 것과 같은 간단한 부트 로더는 알려진 디스크 위치에서 모든 기능을 갖춘 부트 로더를 로드하며, 종종 디스크 자체를 구동하려고 하기보다 디스크 액세스를 위해 공간이 덜 제한된 BIOS에 의존합니다. 그러면 전체 로더가 512바이트 제한에서 벗어나 원하는 커널을 찾고, 로드하고, 실행하는 데 필요한 복잡성을 구현할 수 있습니다. 아마도 더 현대적인 디자인에서는 BIOS가 디스크에서 더 큰 부트 로더를 직접 읽도록 하고 보호 및 32비트 모드에서 시작합니다.
이 부록은 전원이 켜진 후 부트 로더가 실행되는 사이에 BIOS가 부트 섹터를 로드하는 것뿐인 것처럼 작성되었습니다. 사실 BIOS는 현대 컴퓨터의 복잡한 하드웨어를 전통적인 표준 PC처럼 보이게 하기 위해 엄청난 양의 초기화를 수행합니다.