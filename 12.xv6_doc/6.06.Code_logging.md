## Code: logging

#### initlog

```c
void
initlog(int dev)
{
  if (sizeof(struct logheader) >= BSIZE)
    panic("initlog: too big logheader");

  struct superblock sb;
  initlock(&log.lock, "log");
  readsb(dev, &sb);
  log.start = sb.logstart;
  log.size = sb.nlog;
  log.dev = dev;
  recover_from_log();
}
```



A typical use of the log in a system call looks like this:

```c
begin_op();
...
bp = bread(...);
bp->data[...] = ...;
log_write(bp);
...
end_op();
```

#### begin_op

```c
#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
#define FSSIZE       1000  // size of file system in blocks


// Contents of the header block, used for both the on-disk header block
// and to keep track in memory of logged block# before commit.
struct logheader {
  int n;               <----------count 
  int block[LOGSIZE];
};

struct log {
  struct spinlock lock;
  int start;
  int size;
  int outstanding; // how many FS sys calls are executing.
  int committing;  // in commit(), please wait.
  int dev;
  struct logheader lh;
};
struct log log;
```



```c
/ called at the start of each FS system call.
void
begin_op(void)
{
  acquire(&log.lock);
  while(1){
    if(log.committing){
      sleep(&log, &log.lock);
    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
      // this op might exhaust log space; wait for commit.
      sleep(&log, &log.lock);
    } else {
      log.outstanding += 1;
      release(&log.lock);
      break;
    }
  }
}
```

* begin_op은 로깅 시스템이 현재 커밋 중이 아닐 때까지 기다린다.

*  지금의 system call로 부터의 log 쓰기에 충분한 용량과  현재 실행 중인 모든 시스템 호출의 쓰기에 충분한 여유 로그 공간이 있을 때까지 기다립니다. 
* log.outstanding은 system call의 갯수를 계산한다. 

* 증분은 공간을 예약하고 이 시스템 호출 중에 커밋이 발생하는 것을 방지합니다. 

*  코드는 각 시스템 호출이 최대 MAXOPBLOCKS개의 개별 블록을 쓸 수 있다고 보수적으로 가정합니다.





##### log_write

```c
#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache


// Caller has modified b->data and is done with the buffer.
// Record the block number and pin in the cache with B_DIRTY.
// commit()/write_log() will do the disk write.
//
// log_write() replaces bwrite(); a typical use is:
//   bp = bread(...)
//   modify bp->data[]
//   log_write(bp)
//   brelse(bp)
void
log_write(struct buf *b)
{
  int i;

  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
    panic("too big a transaction");
  if (log.outstanding < 1)
    panic("log_write outside of trans");

  acquire(&log.lock);
  for (i = 0; i < log.lh.n; i++) {
    if (log.lh.block[i] == b->blockno)   // log absorbtion
      break;
  }
  log.lh.block[i] = b->blockno;
  if (i == log.lh.n)
    log.lh.n++;
  b->flags |= B_DIRTY; // prevent eviction
  release(&log.lock);
}
```

* log_write는 bwrite의 프록시 역할을 한다. 
* 블록의 섹터 번호를 메모리에 기록하고 디스크의 로그에 슬롯을 예약하고 버퍼 B_DIRTY를 표시하여 블록 캐시가 해당 섹터를 축출하지 못하도록 합니다. 

블록은 커밋될 때까지 캐시에 남아 있어야 합니다. 그때까지 캐시된 복사본은 수정 사항의 유일한 기록입니다.

커밋이 끝날 때까지 디스크의 해당 위치에 쓸 수 없습니다. 동일한 트랜잭션의 다른 읽기는 수정 사항을 확인해야 합니다. 

* log absorbtion: log_write는 단일 트랜잭션 동안 블록이 여러 번 작성될 때 이를 통지하고 해당 블록을 로그의 동일한 슬롯에 할당합니다.  이 최적화를 종종 흡수라고 합니다. 

* 예를 들어, 여러 파일의 inode를 포함하는 디스크 블록은 트랜잭션 내에서 여러 번 작성되는 것이 일반적입니다. 

* 여러 디스크 쓰기를 하나로 흡수함으로써 파일 시스템은 로그 공간을 절약할 수 있고 디스크 블록의 복사본 하나만 디스크에 기록해야 하기 때문에 더 나은 성능을 얻을 수 있습니다.



#### end_op

```c
// called at the end of each FS system call.
// commits if this was the last outstanding operation.
void
end_op(void)
{
  int do_commit = 0;

  acquire(&log.lock);
  log.outstanding -= 1;
  if(log.committing)  panic("log.committing");
  if(log.outstanding == 0){
    do_commit = 1;
    log.committing = 1;
  } else {
    // begin_op() may be waiting for log space,
    // and decrementing log.outstanding has decreased
    // the amount of reserved space.
    wakeup(&log);
  }
  release(&log.lock);

  if(do_commit){
    // call commit w/o holding locks, since not allowed
    // to sleep with locks.
    commit();
    acquire(&log.lock);
    log.committing = 0;
    wakeup(&log);
    release(&log.lock);
  }
}
```



end_op은 먼저 미해결 시스템 호출 수를 줄입니다. 카운트가 이제 0이면 commit()을 호출하여 현재 트랜잭션을 커밋합니다. 

이 과정에는 4단계가 있습니다. 

write_log()는 트랜잭션에서 수정된 각 블록을 버퍼 캐시에서 디스크의 로그 슬롯으로 복사합니다.

write_head()는 헤더 블록을 디스크에 씁니다. 이것은 커밋 지점이고 쓰기 후 충돌은 로그에서 트랜잭션의 쓰기를 재생하는 복구로 이어집니다. 

install_trans() in-stall_trans는 로그에서 각 블록을 읽고 파일 시스템의 적절한 위치에 씁니다. 

마지막으로 end_op는 카운트가 0인 로그 헤더를 작성합니다. 이것은 다음 트랜잭션이 기록된 블록을 쓰기 시작하기 전에 일어나야 하므로 충돌로 인해 후속 트랜잭션의 기록된 블록이 있는 한 트랜잭션의 헤더를 사용하여 복구가 발생하지 않습니다.

recover_from_log는 첫 번째 사용자 프로세스가 실행되기 전에 부팅하는 동안 호출되는 initlog에서 호출됩니다. 로그 헤더를 읽고 헤더에 커밋된 트랜잭션이 포함되어 있음을 나타내는 경우 end_op의 동작을 모방합니다.
로그의 사용 예는 filewrite에서 발생합니다. 트랜잭션은 다음과 같습니다.

이 코드는 로그 오버플로를 방지하기 위해 한 번에 몇 개 섹터의 개별 트랜잭션으로 대용량 쓰기를 나누는 루프로 래핑됩니다. 

writei에 대한 호출은 이 트랜잭션의 일부로 파일의 inode, 하나 이상의 비트맵 블록 및 일부 데이터 블록과 같은 많은 블록을 씁니다.



```c
begin_op();
ilock(f->ip);
r = writei(f->ip, ...);
iunlock(f->ip);
end_op();
```

