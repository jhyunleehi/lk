## Code: Pipes

이 장의 앞부분에서 사용한 간단한 대기열은 장난감이었지만 xv6에는 읽기 및 쓰기를 동기화하기 위해 절전 및 깨우기를 사용하는 두 개의 실제 대기열이 포함되어 있습니다. 하나는 IDE 드라이버에 있습니다. 프로세스는 디스크 요청을 대기열에 추가한 다음 절전 모드를 호출합니다. 인터럽트 핸들러는 요청이 완료되었음을 프로세스에 알리기 위해 웨이크업을 사용합니다.
더 복잡한 예는 파이프의 구현입니다. 0장에서 파이프용 인터페이스를 보았습니다. 파이프의 한쪽 끝에 쓰여진 바이트는 커널 내 버퍼에 복사된 다음 파이프의 다른 쪽 끝에서 읽을 수 있습니다. 다음 장에서는 파이프를 둘러싼 파일 시스템 지원을 조사할 것이지만 지금은 pipewrite 및 piperead의 구현을 살펴보겠습니다.
각 파이프는 잠금 및 데이터 버퍼를 포함하는 구조체 파이프로 표시됩니다. nread 및 nwrite 필드는 버퍼에서 읽고 쓴 바이트 수를 계산합니다. 버퍼가 래핑됩니다. buf[PIPESIZE-1] 다음에 기록되는 다음 바이트는 buf[0]이지만 카운트는 래핑되지 않습니다. 이 규칙을 사용하면 구현에서 전체 버퍼(nwrite == nread+PIPESIZE)와 빈 버퍼 nwrite ==를 구별할 수 있습니다.
nread), 그러나 버퍼에 대한 인덱싱은 buf[nread] 대신 buf[nread % PIPESIZE]를 사용해야 함을 의미합니다(nwrite의 경우에도 유사). piperead 및 pipewrite에 대한 호출이 두 개의 다른 CPU에서 동시에 발생한다고 가정해 보겠습니다.
Pipewrite(6530)는 카운트, 데이터 및 관련 불변량을 보호하는 파이프 잠금을 획득하는 것으로 시작합니다. 그런 다음 Piperead(6551)도 잠금을 얻으려고 시도하지만 할 수 없습니다. 잠금을 기다리는 획득(1574)에서 회전합니다. piperead가 대기하는 동안 pipewrite는 기록 중인 바이트(addr[0], addr[1], ..., addr[n-1])를 반복하여 각각을 파이프에 차례로 추가합니다(6544). 이 루프 동안 버퍼가 채워질 수 있습니다(6536). 이 경우 pipewrite는 버퍼에 대기 중인 데이터가 있다는 사실을 잠자는 독자에게 경고하기 위해 wakeup을 호출한 다음 &p->nwrite에서 잠자기 상태에서 독자가 버퍼에서 일부 바이트를 가져갈 때까지 기다립니다. Sleep은 pipewrite의 프로세스를 절전 모드로 전환하는 일부로 p->lock을 해제합니다.



이제 p->lock을 사용할 수 있으므로 piperead는 이를 획득하고 본격적으로 실행을 시작합니다. p->nread != p->nwrite(6556)(p->nwrite == p- >nread+PIPESIZE (6536)) 따라서 for 루프로 넘어가 파이프 밖으로 데이터를 복사하고(6563-6567), 복사된 바이트 수만큼 nread를 증가시킵니다. 많은 바이트가 이제 쓰기에 사용 가능하므로 piperead는 호출자에게 반환되기 전에 잠자는 작성자를 깨우기 위해 wakeup(6568)을 호출합니다. Wakeup은 pipewrite를 실행하고 있었지만 버퍼가 채워지면 중지된 프로세스인 &p->nwrite에서 잠자는 프로세스를 찾습니다. 해당 프로세스를 RUNNABLE로 표시합니다.
파이프 코드는 판독기와 기록기에 대해 별도의 절전 채널을 사용합니다( p->nread 및 p->nwrite). 이것은 동일한 파이프를 기다리는 많은 판독기와 작성기가 있는 드문 경우에 시스템을 보다 효율적으로 만들 수 있습니다. 파이프 코드는 휴면 상태를 확인하는 루프 내에서 휴면합니다. 여러 판독기 또는 작성기가 있는 경우 깨어나는 첫 번째 프로세스를 제외한 모든 프로세스는 조건이 여전히 거짓임을 확인하고 다시 절전 모드로 전환합니다.