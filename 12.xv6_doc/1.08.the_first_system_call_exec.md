## The first system call: exec

이제 커널이 프로세스에 대해 강력한 격리를 제공하는 방법을 보았고 사용자 수준 프로세스가 자체적으로 수행할 수 없는 서비스를 요청하기 위해 커널에 다시 입력하는 방법을 살펴보겠습니다.
initcode.S의 첫 번째 작업은 exec 시스템 호출을 호출하는 것입니다. 0장에서 보았듯이 exec는 현재 프로세스의 메모리와 레지스터를 새 프로그램으로 교체하지만 파일 설명자, 프로세스 ID 및 상위 프로세스는 변경되지 않은 상태로 둡니다.

Initcode.S(8208)는 스택에 $argv, $init 및 $0의 세 가지 값을 푸시하는 것으로 시작한 다음 %eax를 SYS_exec로 설정하고 int T_SYSCALL을 실행합니다. 커널에 exec 시스템 호출을 실행하도록 요청합니다. 모든 것이 잘되면 exec는 반환하지 않습니다. 실행을 시작합니다.
NUL 종료 문자열 /init(8221-8223)에 대한 포인터인 $init로 명명된 프로그램입니다. exec가 실패하고 반환되면 initcode는 종료 시스템 호출을 반복하며 반환하지 않아야 합니다(8215-8219).

exec 시스템 호출에 대한 인수는 $init 및 $argv입니다. 마지막 0은 이 손으로 작성한 시스템 호출을 3장에서 볼 수 있는 일반 시스템 호출처럼 보이게 합니다. 이전과 마찬가지로 이 설정은 첫 번째 프로세스(이 경우,
첫 번째 시스템 호출) 대신 xv6이 표준 작업을 위해 제공해야 하는 코드를 재사용합니다.
2장에서는 exec의 구현을 자세히 다루지만 높은 수준에서는 initcode를 파일 시스템에서 로드된 /init 바이너리로 대체합니다. 이제 initcode(8200)가 완료되고 프로세스가 대신 /init를 실행합니다. Init(8310)는 필요한 경우 새 콘솔 장치 파일을 생성한 다음 파일 설명자 0, 1 및 2로 엽니다. 그런 다음 루프를 실행하여 콘솔 셸을 시작하고 셸이 종료될 때까지 고아 좀비를 처리하고 반복합니다. 시스템이 작동합니다.