## Systems calls, exceptions, and interrupts

시스템 호출을 통해 사용자 프로그램은 지난 장의 끝에서 보았듯이 운영 체제 서비스를 요청할 수 있습니다. 예외라는 용어는 인터럽트를 생성하는 잘못된 프로그램 동작을 나타냅니다.

잘못된 프로그램 작업의 예로는 0으로 나누기, 존재하지 않는 PTE에 대한 메모리 액세스 시도 등이 있습니다. 인터럽트라는 용어는 하드웨어 장치에서 생성된 신호로 운영 체제의 주의가 필요함을 나타냅니다.

예를 들어, 클럭 칩은 커널이 시간 공유를 구현할 수 있도록 100msec마다 인터럽트를 생성할 수 있습니다. 다른 예로, 디스크가 디스크에서 블록을 읽을 때 인터럽트를 생성하여 블록을 검색할 준비가 되었음을 운영 체제에 경고합니다.

대부분의 경우 커널에만 필요한 권한과 상태가 있기 때문에 커널은 인터럽트를 처리하는 프로세스가 아니라 모든 인터럽트를 처리합니다. 예를 들어 클럭 인터럽트에 응답하여 프로세스 간에 시간 분할을 수행하려면 비협조적인 프로세스가 프로세서를 제공하도록 강제하는 경우에만 커널이 관여해야 합니다.

세 가지 경우 모두에서 운영 체제 설계는 다음이 발생하도록 준비해야 합니다. 시스템은 향후 투명한 재개를 위해 프로세서의 레지스터를 저장해야 합니다.
시스템은 커널에서 실행되도록 설정되어야 합니다. 시스템은 커널이 실행을 시작할 장소를 선택해야 합니다. 커널은 이벤트에 대한 정보(예: 시스템 호출 인수)를 검색할 수 있어야 합니다. 이 모든 작업은 안전하게 수행되어야 합니다. 시스템은 사용자 프로세스와 커널의 격리를 유지해야 합니다.

이 목표를 달성하기 위해 운영 체제는 하드웨어가 시스템 호출, 예외 및 인터럽트를 처리하는 방법에 대한 세부 사항을 알고 있어야 합니다. 대부분의 프로세서에서 이 세 가지 이벤트는 단일 하드웨어 메커니즘으로 처리됩니다. 예를 들어 x86에서 프로그램은 int 명령어를 사용하여 인터럽트를 생성하여 시스템 호출을 호출합니다.

마찬가지로 예외도 인터럽트를 생성합니다. 따라서 운영 체제에 인터럽트 처리 계획이 있는 경우 운영 체제는 시스템 호출과 예외도 처리할 수 있습니다.

기본 계획은 다음과 같습니다. 인터럽트는 일반 프로세서 루프를 중지하고 인터럽트 핸들러라고 하는 새 시퀀스 실행을 시작합니다. 인터럽트 핸들러를 시작하기 전에 프로세서는 레지스터를 저장하여 운영 체제가 인터럽트에서 돌아올 때 레지스터를 복원할 수 있도록 합니다. 인터럽트 핸들러로 또는 인터럽트 핸들러에서 전환할 때의 문제는 프로세서가 사용자 모드에서 커널 모드로, 그리고 그 반대로 전환해야 한다는 것입니다.

용어 설명: 공식 x86 용어는 인터럽트이지만 xv6은 이 모든 것을 트랩이라고 합니다. 이는 주로 PDP11/40에서 사용하는 용어이고 따라서 기존 Unix 용어이기 때문입니다.

이 장에서는 트랩과 인터럽트라는 용어를 같은 의미로 사용하지만 트랩은 프로세서에서 실행 중인 현재 프로세스(예: 프로세스가 시스템 호출을 만들고 결과적으로 트랩을 생성함)에 의해 발생하고 인터럽트가 발생한다는 점을 기억하는 것이 중요합니다. 장치에 따라 다르며 현재 실행 중인 프로세스와 관련이 없을 수 있습니다. 예를 들어, 디스크는 한 프로세스에 대한 블록 검색이 완료되었을 때 인터럽트를 생성할 수 있지만 인터럽트 시간에 다른 프로세스가 실행 중일 수 있습니다.

인터럽트의 이러한 속성은 인터럽트가 다른 활동과 동시에 발생하기 때문에 트랩에 대해 생각하는 것보다 인터럽트에 대해 생각하는 것이 더 어렵습니다. 그러나 둘 다 동일한 하드웨어 메커니즘에 의존하여 사용자와 커널 모드 간에 안전하게 제어를 전달합니다. 이에 대해서는 다음에 논의합니다.